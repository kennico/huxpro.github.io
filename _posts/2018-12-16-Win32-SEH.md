---
layout: post
title: "Structured Exception Handling"
subtitle: "Windows 异常处理机制"
date: 2018-12-16 14:35
tags: 
    - Assembly
    - Win32
---

# Content
微软靠 OS 和编译器提供了一套异常处理机制(Structured Exception Handling, SEH)。使用了 SEH 的代码通常按照如下形式组织：

```cpp
__try 
{
    // guarded body of code  
} 
__except (/*filter-expression*/) 
{ 
    // exception-handler block 
}
```

这里的 `__try`/`__except` 有别于标准 C++ 的中的 `try`/`catch`，尽管使用 SEH 的代码在形式上类似于其它面向对象编程语言的异常处理(包括标准C++)。相比之下， SEH 能够处理的异常类型有限而且更贴近硬件（比如整数除 0 异常和非法访问内存）；或许这种特点是由那些使用 C 语言设计 Windows 的微软工程师决定的。

本文是 [A Crash Course on the Depths of Win32™ Structured Exception Handling](https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm) 的笔记，原文作者是 Matt Pietrek。


## How does it know where to call when exception occurs

在执行函数 A 的过程中出现了异常，函数 A 被中断执行，异常沿着函数调用的相反方向传播直到在某个函数 B 中得到了正确处理，然后函数 B 继续执行。这是 java, python 异常处理的一般思路。SEH 机制和上述流程类似；顺带提一下，和 java 以及 python 不同的是，OS 还允许使用 SEH 的程序从引起异常的指令处重新执行。整个 SEH 机制离不开一个名为 SEH 链(SEH chain)的数据结构（多数调试器，比如 ollydbg, x64dbg, 都提供查看 SEH 链的功能）。那么如何通过这个数据结构实现类似的异常传播和异常处理？

### SEH chain

SEH 链表是一个单向链接的链表。它的结点，姑且称之为 SEH 记录，其结构如下所示：

```cpp

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

// The following definition is not presented in SDK.
typedef EXCEPTION_REGISTRATION_RECORD EXCEPTION_REGISTRATION; 
```

`Next` 指向下一个结点，`Handler` 是 **异常回调函数(Exception callback function)** 的函数指针。如下图所示，SEH 链表中的所有结点按照自底向上的顺序存储在栈上(需要注意的是，图中的`prev` 指针其实就是 `Next` 指针)。因为 x86 栈向下生长，头结点位于低地址。为了在任意时候访问 SEH 链表，TEB 块 `fs:[0]` 处用作存储 SEH 链表的头结点的地址，这可能是因为每个线程都需要单独的互不干涉的异常处理逻辑。

![Finding a structure to handling exception]({{ "img/win32-seh-fig04.jpg" | absolute_url }})

SEH 链表的结构随着函数调用而动态变化。当程序进入带有 `__try` 块的函数时，首先会在栈顶创建一个 SEH 记录，使得 `Next` 指向上一个 SEH 记录，以及 `Handler` 指向一个异常回调函数；接着程序将这个新的 SEH 记录的地址赋值给 `fs:[0x0]`，因此 `fs:[0x0]` 在任意时候都指向最靠近栈顶的 SEH 记录，也就是 SEH 链的头结点。简单来说，当异常发生时，程序首先通过当前线程的 `fs:[0]` 找到第一个 SEH 结点的地址，从第一个结点开始遍历 SEH 链表直到某个结点的异常回调函数(Handler)能够正确地处理异常，最后 **程序依据这个回调函数的返回值决定控制流**。

### Exception callback

那么程序如何得知异常回调函数是否能够正确地处理异常？上文提到的异常回调函数的签名如下：

```cpp
int except_handler(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);
```

`EXCEPTION_RECORD` 包含了异常相关信息，其结构如下：

```cpp
typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;
```

_在遍历 SEH 链表结点的时候，程序会执行一次异常回调函数_，函数如果返回 `DISPOSITION_CONTINUE_SEARCH` 就表示它无法处理，需要遍历下一个结点。从原文提供的[伪代码](https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/Win32SEH.chm/fig14.htm)来看，异常回调函数有多个返回值。幸运的是，开发者不需要手动实现一个异常回调函数；开发者需要做的是提供 filter 表达式以及 exception-handler 代码块，而后面的过程可以先简单看作由异常回调函数对 filter 表达式求值，然后决定是否调用 exception-handler 代码块。

有的时候程序控制流不会再返回到这个回调函数，这表示回调函数可以正常处理异常。详情见[后文]({{ page.url }}#exception-callback---_except_handler3())。

### The last resort exception handler

SEH 链表的最后一个结点由 OS 在启动进程的时候在生成，以确保所有异常都能被处理；不出意外地，调用入口点函数(entry point)也是被 `__try`/`__except` 包围。一般情况下，如果用户没有调用 `SetUnhandledExceptionFilter()` 更改函数指针，这个结点的异常回调函数会调用 `UnhandledExceptionFilter()`。如果[ WER 被关闭](https://docs.microsoft.com/en-us/visualstudio/debugger/debug-using-the-just-in-time-debugger?view=vs-2017#jit_errors)，这个函数将弹出一个深表歉意的对话框，然后让你选择是退出还是调试；要是你选择调试，实时调试器就会启动并且附加到当前进程。如果系统启用了自动调试，弹窗将不会出现而且直接启动调试器。

顺带一提，启动调试器这个过程涉及进程间通信。由于句柄只是数组索引而已，因此这个过程得以通过在命令参数中传递事件句柄来实现共享内核对象。

## Stack unwinding

鉴于函数之间存在嵌套调用关系，引发异常的函数和异常得到处理的函数（不是异常回调函数）可能不是同一个。这意味着控制流不一定从引发异常的地方继续：如果控制流跳回到后面的 B 函数， C 和 A（包括引起异常的函数）可能无法正常退出。

- B()
    - C()
        - A()
            - exception happens

_为了让无法处理异常的函数能正常退出，异常回调函数将被再一次调用_。在此期间，程序执行 **stack unwinding** 操作，把 esp 和 ebp 还原到 SEH 记录对应的栈帧的值。借助下图可以把这一通操作直观地理解为压缩栈。stack unwinding 除了需要还原上下文之外，还需执行必要清理工作以释放资源。举个例子，C++ 标准规定局部变量的析构函数必须被调用；如果栈帧的异常回调函数无法处理异常，析构函数将无法执行。为了实现C++标准规定的行为，析构函数会在 stack unwinding 过程中被调用。

![Stack unwinding]({{ "img/win32-seh-fig06.jpg" | absolute_url }})

异常回调函数可以通过区分当前是第一次调用还是第二次调用：参数 `ExceptionFlags` 的 `EH_UNWINDING` 位为 1 表示正在进行 stack unwinding 操作。那些对异常无能为力的回调函数将在这个过程中默默完成自己的善后工作。发生 stack unwinding 之后，在栈上所有位于 B  之前的内容都被擦除（其实只是简单地压低栈顶而已），当然也包括 SEH 记录。

## A compiler's perspective

实际上， SEH 记录的结构 `EXCEPTION_REGISTRATION` 可能比单纯两个指针要复杂得多；而且 `__try`/`__except` 块和 SEH 记录并非一一对应关系。然而对于 ntdll 来说，它只看得到两个指针而已。上述被原文作者 Matt Pietrek 称之为"ugly reality" 和 "twist to simplistic view" 的工作借由编译器和运行时库代码完成。

再次把关注焦点放到异常处理函数上。事实上多数 SEH 记录的 `Handler` 指针都指向同一个函数：

- `_except_handler4()`，或
- `_except_handler3()`

在 VS2017 （默认工具集或兼容XP的工具集）编译出来的程序中，所有由用户代码 `__try`/`__except` 生成的异常回调函数指针都指向 `_except_handler4()`；关闭 GS 选项后，这个函数指针变成了 `_except_handler3()`。 两个函数的实现不相同。

### Exception callback - `_except_handler3()`

`_except_handler3()` 需要与一个比单纯两个指针更加复杂的 `EXCEPTION_REGISTRATION` 结构来配合食用：

```cpp

struct scopetable_entry;

struct EXCEPTION_REGISTRATION {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
    scopetable_entry* scopetable;
    int trylevel;
    int _ebp;
};

struct scopetable_entry {
    DWORD previousTryLevel;
    PROC lpfnFilter;
    PROC lpfnHandler;
};
```

`EXCEPTION_REGISTRATION::scopetable` 是一个数组，这个数据结构使得程序只需要一个 SEH 记录就能处理位于同一函数内的多个 `__try`/`__except` 块。数组元素 `scopetable_entry` 的 `lpfnFilter`、`lpfnHandler` 分别对应 `__except` 后圆括号内的 filter 表达式、花括号内 exception-handler 代码块。`scopetable_entry` 之间靠索引 `previousTryLevel` 串成单向链表；`EXCEPTION_REGISTRATION::trylevel` 表示适用于当前异常处理的 `scopetable_entry` 链表的头节点索引。

`_except_handler3()` 的[伪代码](https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/Win32SEH.chm/fig09.htm)很长。它的执行流程大体如下

1. 如果正在进行 unwinding 就转到4；否则继续。
2. 从 scopetable 中取出并遍历链表，调用 `lpfnFilter()` 并根据返回值决定下一步：
    - `EXCEPTION_CONTINUE_SEARCH`: 继续遍历链表；
    - `EXCEPTION_CONTINUE_EXECUTION`: 促使 `_except_handler3()` 返回 `ExceptionContinueExecution`，程序从引发异常的指令重新开始执行；
    - `EXCEPTION_EXECUTE_HANDLER`: 
        - 调用 `__global_unwind2()` -> `RtlUnwind()` -> `RtlpExecuteHandlerForUnwind()` -> `ExecuteHandler()` -> exception-callback() (`_except_handler3()`)
        - 调用 `__local_unwind2()` 清理当前栈帧；
        - 执行 `lpfnHandler()` 然后 **不再返回** 到 `_except_handler3()`。
3. 如果 scopetable 链表中所有 `lpfnFilter()` 都返回 `EXCEPTION_CONTINUE_SEARCH`，这表示当前 `_except_handler3()` 无法处理这个异常，返回 `DISPOSITION_CONTINUE_SEARCH`。这个函数放弃治疗。
4. 执行 `__local_unwind2()` 清理当前栈帧，返回 `DISPOSITION_CONTINUE_SEARCH`。

结合 [stack unwinding]({{ page.url }}#stack-unwinding) 的内容，虽然部分异常回调函数会被调用第二次，但是 `lpfnFilter()` 和 `lpfnHandler()` 并不会被调用第二次；而且只有一个 `lpfnHandler()`，亦即 `__except` 代码块可能被执行。由此可见，正是 `_except_handler3()` 复杂的执行逻辑才能保证程序实现正确的（或者说和开发者脑回路一致的） `__try` / `__except` 语义。

### `__try`/`__except` block with `_except_handler3`

如果编译器决定使用 `_except_handler3` 作为异常回调函数，SEH 记录 `EXCEPTION_REGISTRATION` 的创建过程如下，

1. 压入 `0XFFFFFFFF`(`trylevel`);
2. 压入 scopetable 的地址(`scopetable`, 在 XP 中位于 .rdata);
3. 压入 `_except_handler3` 地址(`Handler`);
4. 压入 `fs:[0]`(`Next`).
5. 修改 `fs:[0]` 为当前栈顶地址。

在函数 prologue 之后，当控制流进入第一个 `__try`，`trylevel` 被设置为 `0`；进入第二个`__try` 代码块时，无论是否嵌套，这个变量的值会+1。当控制流离开 `__try` 或 `__except` 后，这个变量被重新赋值为 `0XFFFFFFFF`。


### `__try`/`__except` block with `_except_handler4`

启用 GS 之后，异常回调函数变成 `_except_handler4` ，而且创建 `EXCEPTION_REGISTRATION` 的过程也发生变化，这其实是因为相应的结构被修改了（虽然不明，可能是 scopetable）。

1. 压入 **`0xFFFFFFFE`**(`trylevel`?)；
2. 压入一个位于 .rdata 的地址，可能还是 scopetable 但结构有变化；
3. 压入 `_except_handler4` 地址；
4. 压入 `fs:[0]`；
5. 修改 `fs:[0]` 为当前栈顶地址；
6. 其它一般操作，比如抬高栈顶；
7. 取出 .data 第一个双字整数(位于 0x00403000)，这个值就是"security cookie"。`trylevel`与之异或(`trylevel ^= (DWORD)(*.data)`)；
8. 压入 ebp 与上述双字整数异或的结果。

和前面的类似，当控制流进入第一个 `__try`，`trylevel` 被设置为 `0`；进入下一个`__try` 代码块时这个变量的值增加 1。当退出 `__try` 或 `__except` 后，这个变量被重新赋值为 `0XFFFFFFFE`。

`_except_handler4()` 调用另一个函数 `_except_handler4_common()`(尾调用)，这个函数比 `_except_handler4` 还要多出来两个参数：

```cpp
int _except_handler4_common(DWORD*, function*, PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD)
```

第一个参数是硬编码的 security cookie 的地址。第二个参数是硬编码的函数指针(0x004031375)，该函数的调用约定可能是 fastcall（靠 ecx 传递参数），其作用是检查实际参数是否等于 security cookie ，如果二者不相等，最后会调用 `UnhandledExceptionFilter()`，通常情况下就是喜闻乐见的弹窗以示歉意；这也就是说，程序直接认为它没法处理异常然后退出。

回到 `_except_handler4_common()`。这个函数做的第一件事情是从参数取出原本应该是 scopetable 指针的值，和 security cookie 异或还原出原来的 scopetable 的地址。不过反汇编就只看到这里了，剩下的过程没有继续研究。

### Show SEH frames

下面的代码是在文章[例子](https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/Win32SEH.chm/fig10.htm)的基础上稍加修改得到的。这个例子的作用是输出 SEH 链以及 scopetable 信息。

原来的代码编译后当然不能正常运行，XP 也不行。原来的 scopetable 指针已经和 security cookie 异或，尝试读取位于此处的数据时必然引起非法访问异常(0xC0000005)。例子经过修改加上了异常处理。

```cpp
#include <Windows.h>
#include <cstdio>

typedef EXCEPTION_REGISTRATION_RECORD EXCEPTION_REGISTRATION;

struct scopetable_entry {
    DWORD previousTryLevel;
    PROC lpfnFilter;
    PROC lpfnHandler;
};

struct VC_EXCEPTION_REGISTRATION {
    VC_EXCEPTION_REGISTRATION *Next;
    PEXCEPTION_ROUTINE Handler;
    scopetable_entry* scopetable;
    int trylevel;
    int _ebp;
};

extern "C" int _except_handler3(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);
extern "C" int _except_handler4(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);

void ShowScopeTableInFrame(VC_EXCEPTION_REGISTRATION*);
void WalkSEHFrame();
void Function();

int main(int argc, char* argv[], char* envp[]) {
    // TODO main
    int i;
    _try{
        i = 0x1234;
    }_except(EXCEPTION_CONTINUE_SEARCH) {
        i = 0x4321;
    }

    __asm int 3
    __try{
        Function();
    }__except(EXCEPTION_CONTINUE_SEARCH) {
        printf("caught in %s\n", __FUNCTION__);
    }
    //_asm int 3
    return 0;
}

void ShowScopeTableInFrame(VC_EXCEPTION_REGISTRATION * pVCExcRec) {
    printf("Frame: 0x%p Handler: 0x%p Prev: 0x%p Scopetable: 0x%p\n",
        pVCExcRec, pVCExcRec->Handler, pVCExcRec->Next, pVCExcRec->scopetable);

    __try {
        scopetable_entry* pScopeTableEntry = pVCExcRec->scopetable;
        for (int i = 0; i <= pVCExcRec->trylevel; ++i) {
            printf(" scopetable[%u] previousTryLevel: %08X filter: 0x%p __except: 0x%p\n",
                i, pScopeTableEntry->previousTryLevel, pScopeTableEntry->lpfnFilter, pScopeTableEntry->lpfnHandler);

            pScopeTableEntry++;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        printf(" Exception occurs. Code:0x%08X\n", GetExceptionCode());
    }

    printf("\n");
}

void WalkSEHFrame() {
    printf("_except_handler3 is at address: 0x%p\n", _except_handler3);
    printf("_except_handler4 is at address: 0x%p\n", _except_handler4);

    VC_EXCEPTION_REGISTRATION* pVCExcRec;
    _asm {
        mov eax, fs:[0x0]
        mov pVCExcRec, eax
    }
    printf("The top SEH node is at address: 0x%p\n\n", pVCExcRec);

    while (0xffffffff != (unsigned)pVCExcRec) {
        ShowScopeTableInFrame(pVCExcRec);
        pVCExcRec = pVCExcRec->Next;
    }
}

void Function() {
    __try {
        __try {
            __try {
                WalkSEHFrame();
            } __except (EXCEPTION_CONTINUE_SEARCH) {

            }
        } __except (EXCEPTION_CONTINUE_SEARCH) {

        }
    } __except (EXCEPTION_CONTINUE_SEARCH) {

    }
}
```

OS|IDE|Configuration
-|-|-
Windows XP Professional SP3|VS2017|Release|

- 默认开启 GS

![Disabled security check]({{ "img/win32-seh-xp-showsehframes-gs.png" | absolute_url }})

- 关闭 GS

![Disabled security check]({{ "img/win32-seh-xp-showsehframes.png" | absolute_url }})


从上边两个图片可以看出来，因为 GS 默认是打开的，所以 VS2017 的编译器使用 `_except_handler4()` 作为异常回调函数。

## Conclusion

对于 ntdll 而言，ntdll 只要找到 SEH 链，调用异常回调函数然后根据其返回值决定下一步行动。然而实际上更多的工作，包括（stack unwinding, 嵌套/多个`__try`/`__except`结构）靠编译器生成代码来完成。

### A more detailed view

当程序从 OS 接过异常的时候，控制流进入到 `KiUserExceptionDispatcher()`，该函数立即调用 `RtlDispatcherException()`。`RtlDispatcherException()` 通过 `RtlpGetRegistrationHead()` 获取 SEH 链表头结点，在遍历链表结点的过程中做了一堆验证工作(栈帧是否有效、是否对齐)再调用 `RtlpExecuteHandlerForException()`，然后跳转到 `ExecuteHandler()`。异常回调函数的指针（比如 `_except_handler3()`），作为最后一个（第五个）参数传递到 `ExecuteHandler()`，在 `ExecuteHandler()` 当中被调用。

本文只讨论 SEH 机制的小部分内容，并没有讨论更多细节，比如 OS 如何监视并得知异常出现，派发异常的过程 `RtlDispatcherException()`（负责遍历 SEH 链），实际上完成 unwind 操作的 `RtlUnwind()`等等。更多的内容还要拜读 Matt Pietrek 的[原文](https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm)。

