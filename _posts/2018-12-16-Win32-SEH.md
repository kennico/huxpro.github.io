---
layout: post
title: "Structured Exception Handling"
subtitle: "Windows 异常处理机制"
date: 2018-12-16 14:35
tags: 
    - Assembly
    - Win32
---

# Content
微软靠 OS 和编译器提供了一套异常处理机制(Structured Exception Handling, SEH)。一段典型的使用了 SEH 的代码通常按照如下形式组织：

```cpp
__try 
{
    // guarded body of code  
} 
__except (/*filter-expression*/) 
{ 
    // exception-handler block 
}
```

注意，`__try`/`__except` 有别于标准 C++ 的中的 `try`/`catch`。使用 SEH 的代码，在形式上类似于其它面向对象编程语言的异常处理(包括标准C++)。相比之下， SEH 所能够处理的异常类型有限而且更贴近硬件（比如整数除 0 异常和非法访问内存）；或许这种特点是由那些使用 C 语言设计 Windows 的微软工程师决定的。

本文是 [A Crash Course on the Depths of Win32™ Structured Exception Handling](https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm) 的笔记，原文作者是 Matt Pietrek。


## How does it know where to call when exception occurs

程序在出现异常时被中断执行，异常沿着函数调用的相反方向传播直到在某个函数中异常得到了正确处理，然后程序从这里开始继续执行。这是 java, python 异常处理的一般思路。

SEH 机制和上述流程类似；和 java 以及 python 不同的是，OS 还允许使用 SEH 的程序从引起异常的指令处重新执行。整个 SEH 机制离不开一个名为 SEH 链(SEH chain)的数据结构（多数调试器，比如 ollydbg, x64dbg, 都提供查看 SEH 链的功能）。那么如何通过这个数据结构实现类似的异常传播和异常处理？

### SEH chain

SEH 链表是一个单向链接的链表。它的结点，姑且称之为 SEH 记录，其结构如下所示：

```cpp

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

// The following definition is not presented in SDK.
typedef EXCEPTION_REGISTRATION_RECORD EXCEPTION_REGISTRATION; 
```

`Next` 指向下一个结点，`Handler` 是 **异常回调函数(Exception callback function)** 的函数指针。如下图所示，SEH 链表中的所有结点在栈上在按照自底向上的顺序存储(需要注意的是，图中的`prev` 指针其实就是 `Next` 指针)。其中， TEB 块 `fs:[0]` 是一个指针，存储 SEH 链表的第一个结点的地址，这可能是因为每个线程都需要单独的互不干涉的异常处理逻辑。

![Finding a structure to handling exception]({{ "img/win32-seh-fig04.jpg" | absolute_url }})

SEH 链表的结构随着函数调用而动态变化。当程序进入带有 `__try` 块的函数时，首先会在栈顶创建一个 SEH 记录，使得 `Next` 指向上一个 SEH 记录，以及`Handler` 指向一个异常回调函数。由于栈会生长，为了后续可以正常访问 SEH 链表，程序将 `fs:[0x0]` 的指向这个新的 SEH 记录，这样 `fs:[0x0]` 在任何时候都能指向最靠近栈顶的 SEH 记录。

简单来说，当异常发生时，程序首先通过当前线程的 `fs:[0]` 找到第一个 SEH 结点的地址，从第一个结点开始遍历 SEH 链表直到某个结点的异常回调函数(Handler)能够正确地处理异常，最后 **程序依据这个回调函数的返回值决定控制流**。

### Exception callback
那么程序如何得知异常回调函数是否能够正确地处理异常？上文提到的异常回调函数的签名如下：

```cpp
int except_handler(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);
```

`EXCEPTION_RECORD` 包含了异常相关信息，其结构如下：

```cpp
typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;
```

`KiUserExceptionDispatcher` 负责遍历 SEH 链以及调用异常回调函数。在遍历 SEH 链表结点的时候，程序总是先执行一次异常回调函数，如果异常回调函数返回 `DISPOSITION_CONTINUE_SEARCH` 就表示它无法处理，需要遍历下一个结点。从原文提供的[伪代码](https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/Win32SEH.chm/fig14.htm)来看，异常回调函数有多个返回值。幸运的是，开发者不需要手动实现一个异常回调函数；开发者需要做的是提供 filter 表达式以及 exception-handler 代码块。粗略地说，正是异常回调函数对 filter 表达式求值然后决定是否调用 exception-handler 代码块。

有的时候程序控制流不会再返回到这个回调函数，这表示回调函数可以正常处理异常。详情见[后文]({{ page.url }}#exception-callback---_except_handler3)。

### The last resort exception handler

SEH 链表的最后一个结点由 OS 为所有线程在栈上生成以确保所有异常都能被处理；入口点的调用也是被`__try`/`__except` 包围。一般情况下，如果用户没有调用 `SetUnhandledExceptionFilter()` 更改函数指针，这个结点的异常处理函数会调用 `UnhandledExceptionFilter()`。在[ WER 被关闭并启用自动调试](https://docs.microsoft.com/en-us/visualstudio/debugger/debug-using-the-just-in-time-debugger?view=vs-2017#jit_errors)的情况下，这个函数的作用就是弹出一个深表歉意的对话框，然后让你选择是退出还是调试。如果你选择调试，那么实时调试器就会启动并且附加到当前进程。

顺带一提，启动调试器这个过程涉及进程间通信。这一过程通过在命令参数中传递事件的句柄来实现共享内核对象。（其实句柄只是索引而已。）

## Stack unwinding

鉴于函数之间存在嵌套调用关系，引发异常的函数和异常得到处理的函数（不是异常回调函数）可能不是同一个。这意味着控制流可能不会从引发异常的地方继续：如果控制流跳回到后面的 caller，caller 以前的函数（包括引起异常的函数）可能无法正常退出。

- caller()
    - callee()
        - exception_happen()

为了实现函数的正常退出，程序会执行一种称为 **stack unwinding**的操作，这个操作的意义在于：

- 还原异常回调函数所在的上下文。相应寄存器比如 ebp, esp 被还原为位于这个栈帧时的值。
- 释放资源。比如 C++ 标准规定局部变量的析构函数必须被调用。如果栈帧的异常回调函数无法处理异常，析构函数将无法执行。

异常回调函数可以通过区分它是正在被第一次调用还是第二次调用：将 `ExceptionFlags` 的 `EH_UNWINDING` 位设置为 1 表示当前正在进行 stack unwinding 操作。那些对异常无能为力的回调函数将在这个过程中完成自己的善后工作。发生 stack unwinding 之后，在栈上所有位于 caller 之前的内容都被擦除（其实只是简单地压低栈顶而已），当然也包括 SEH 记录。

## A compiler's perspective

实际上 SEH 记录 `EXCEPTION_REGISTRATION` 的结构可能比单纯两个指针要复杂得多；而且 `__try`/`__except` 块和 SEH 记录并非一一对应关系。然而对于 ntdll 来说，它只看得到两个指针而已。上述被原文作者 Matt Pietrek 称之为"ugly reality" 和 "twist to simplistic view" 的工作借由编译器和运行时库代码完成。

再次把关注焦点放到异常处理函数上。事实上多数 SEH 记录的 `Handler` 指针都指向同一个函数：

- `_except_handler4`，或
- `_except_handler3`

在 VS2017 （默认工具集或兼容XP的工具集）编译出来的程序中，所有由用户代码 `__try`/`__except` 块生成的异常回调函数指针都指向 `_except_handler4`；关闭 GS 选项后，这个函数指针变成了 `_except_handler3`。 尽管两个函数的实现不相同，但不管是哪一个，这两个异常回调函数都位于当前模块的 .text 段，而且会根据 filter 表达式的值决定是否执行 exception-handler 代码块；后者是明确写在 [MSDN](https://docs.microsoft.com/en-us/windows/desktop/debug/frame-based-exception-handling) 上的。

### Exception callback - `_except_handler3`

`_except_handler3` 使用比两个指针更加复杂的 SEH 记录：

```cpp

struct scopetable_entry;

struct EXCEPTION_REGISTRATION {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
    scopetable_entry* scopetable;
    int trylevel;
    int _ebp;
};

struct scopetable_entry {
    DWORD previousTryLevel;
    PROC lpfnFilter;
    PROC lpfnHandler;
};
```

`EXCEPTION_REGISTRATION::scopetable` 是一个数组，引入这个数据结构使得一个 SEH 记录能处理多个位于同一函数内的 `__try`/`__except` 块。数组元素 `scopetable_entry` 的 `lpfnFilter` 对应 `__except` 后圆括号内的 filter 表达式，`lpfnHandler` 对应花括号内 exception-handler 代码块。


`scopetable_entry` 之间靠索引 `previousTryLevel` 串成单向链表；`EXCEPTION_REGISTRATION::trylevel` 表示适用于当前异常处理的 `scopetable_entry` 链表的头节点索引。

`_except_handler3` 的[伪代码](https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/Win32SEH.chm/fig09.htm)很长。它的执行流程大体如下

1. 判断是否正在进行 unwinding 操作，若是，跳到4；否则继续。
2. 从 scopetable 中取出并遍历链表，调用 `lpfnFilter()` 并根据返回值决定下一步：
    - `EXCEPTION_CONTINUE_SEARCH`: 继续遍历链表；
    - `EXCEPTION_CONTINUE_EXECUTION`: `_except_handler3` 返回 `ExceptionContinueExecution`。程序从引发异常的指令重新开始执行；
    - `EXCEPTION_EXECUTE_HANDLER`: 
        - 调用 `__global_unwind2()` -> `RtlUnwind()` -> `RtlpExecuteHandlerForUnwind()` -> `ExecuteHandler()` -> exception-callback() (`_except_handler3()`)
        - 调用 `__local_unwind2()` 清理当前栈帧；
        - 执行 `lpfnHandler()` 然后 **不再返回** 到 `_except_handler3`。
3. 如果 scopetable 链表中所有 `lpfnFilter()` 都返回 `EXCEPTION_CONTINUE_SEARCH`，这表示当前 `_except_handler3` 无法处理这个异常，返回 `DISPOSITION_CONTINUE_SEARCH`。
4. 执行 `__local_unwind2()` 清理当前栈帧，返回 `DISPOSITION_CONTINUE_SEARCH`。

#### Show SEH frames

下面的代码是在文章[例子](https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/Win32SEH.chm/fig10.htm)的基础上稍加修改得到的。这个例子的作用是输出 SEH 链以及 scopetable 信息。

原来的代码编译后不能正常运行。调试发现，异常回调函数变成了 `_except_handler4`，原本应该是 scopetable 指针的地方现在存储了一个不存在于任何一个模块的“地址”，尝试读取位于此处的数据时引起非法访问异常(0xC0000005)。例子经过修改加上了异常处理。

```cpp
#include <Windows.h>
#include <cstdio>

typedef EXCEPTION_REGISTRATION_RECORD EXCEPTION_REGISTRATION;

struct scopetable_entry {
    DWORD previousTryLevel;
    PROC lpfnFilter;
    PROC lpfnHandler;
};

struct VC_EXCEPTION_REGISTRATION {
    VC_EXCEPTION_REGISTRATION *Next;
    PEXCEPTION_ROUTINE Handler;
    scopetable_entry* scopetable;
    int trylevel;
    int _ebp;
};

extern "C" int _except_handler3(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);
extern "C" int _except_handler4(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);

void ShowScopeTableInFrame(VC_EXCEPTION_REGISTRATION*);
void WalkSEHFrame();
void Function();

int main(int argc, char* argv[], char* envp[]) {
    // TODO main
    int i;
    _try{
        i = 0x1234;
    }_except(EXCEPTION_CONTINUE_SEARCH) {
        i = 0x4321;
    }

    __asm int 3
    __try{
        Function();
    }__except(EXCEPTION_CONTINUE_SEARCH) {
        printf("caught in %s\n", __FUNCTION__);
    }
    //_asm int 3
    return 0;
}

void ShowScopeTableInFrame(VC_EXCEPTION_REGISTRATION * pVCExcRec) {
    printf("Frame: 0x%p Handler: 0x%p Prev: 0x%p Scopetable: 0x%p\n",
        pVCExcRec, pVCExcRec->Handler, pVCExcRec->Next, pVCExcRec->scopetable);

    __try {
        scopetable_entry* pScopeTableEntry = pVCExcRec->scopetable;
        for (int i = 0; i <= pVCExcRec->trylevel; ++i) {
            printf(" scopetable[%u] previousTryLevel: %08X filter: 0x%p __except: 0x%p\n",
                i, pScopeTableEntry->previousTryLevel, pScopeTableEntry->lpfnFilter, pScopeTableEntry->lpfnHandler);

            pScopeTableEntry++;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        printf(" Exception occurs. Code:0x%08X\n", GetExceptionCode());
    }

    printf("\n");
}

void WalkSEHFrame() {
    printf("_except_handler3 is at address: 0x%p\n", _except_handler3);
    printf("_except_handler4 is at address: 0x%p\n", _except_handler4);

    VC_EXCEPTION_REGISTRATION* pVCExcRec;
    _asm {
        mov eax, fs:[0x0]
        mov pVCExcRec, eax
    }
    printf("The top SEH node is at address: 0x%p\n\n", pVCExcRec);

    while (0xffffffff != (unsigned)pVCExcRec) {
        ShowScopeTableInFrame(pVCExcRec);
        pVCExcRec = pVCExcRec->Next;
    }
}

void Function() {
    __try {
        __try {
            __try {
                WalkSEHFrame();
            } __except (EXCEPTION_CONTINUE_SEARCH) {

            }
        } __except (EXCEPTION_CONTINUE_SEARCH) {

        }
    } __except (EXCEPTION_CONTINUE_SEARCH) {

    }
}
```

OS|IDE|Configuration
-|-|-
Windows 10 x64|VS2017|Debug|

- 默认开启 GS

![Disabled security check]({{ "img/win32-seh-showsehframes-gs.png" | absolute_url }})

- 关闭 GS

![Disabled security check]({{ "img/win32-seh-showsehframes.png" | absolute_url }})


从上边两个图片可以看出来 VS2017 的编译器默认使用 `_except_handler4` 作为异常回调函数，而且对应的 `EXCEPTION_REGISTRATION` 不同于 `_except_handler3`。

Release 配置和上述结果基本一致。关闭 GS 后，SEH 链的异常回调函数指针指向一条 jmp 指令，这条指令紧接着跳转到 `_except_handler3`；而使用 `_except_handler4` 则没有此跳转。

## Conclusion


对于 ntdll 而言，ntdll 只要找到 SEH 链，调用异常回调函数然后根据其返回值决定下一步行动。然而实际上更多的工作，包括（stack unwinding, 嵌套`__try`/`__except`）靠编译器生成代码来完成。

本文只涉及了 SEH 机制的小部分内容，许多详细的细节并未提及，比如异常回调函数的调用者 ntdll 的 `KiUserExceptionDispatcher()`（负责遍历 SEH 链）和实际上完成 unwind 操作的 `RtlUnwind()`。更多的内容还要拜读 Matt Pietrek 的[原文](https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm)。

