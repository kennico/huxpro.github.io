---
layout: post
title: "Structured Exception Handling"
subtitle: "站在 OS 和编译器的角度看 Windows 异常处理机制"
date: 2018-12-16 14:35
tags: 
    - Assembly
    - Win32
---

# Content
微软靠 OS 和编译器提供了一套异常处理机制(Structured Exception Handling, SEH)。一段典型的使用了 SEH 异常处理代码通常按照如下形式组织：

```cpp
__try 
{
    // guarded body of code  
} 
__except (/*filter-expression*/) 
{ 
    // exception-handler block 
}
```

注意，`__try`/`__except` 有别于标准 C++ 的中的 `try`/`catch`。使用 SEH 的代码，在形式上类似于其它面向对象编程语言的异常处理(包括标准C++)。相比之下， SEH 所能够处理的异常类型有限而且更贴近硬件（比如整数除 0 异常和非法访问内存）；或许这种特点是由那些使用 C 语言设计 Windows 的微软工程师决定的。

这篇文章是 [A Crash Course on the Depths of Win32™ Structured Exception Handling](https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm) 的笔记。

<!-->
之所以决定按照 OS 和编译器两个方面行文，是因为根据日常 coding 和网上资料，我认为 OS 和编译器在异常处理中扮演了不同的角色。在使用若干调试器(vs自带, x64dbg, ollydbg)的过程中可以注意到，在程序被异常引发中断之后，调试器无法跳进(step into)下一条指令，必须靠给 exception-handler 块或者后续的代码下断点才能继续执行。这可能是异常在发生后需要先交给 OS 处理的缘故？
<!-->

## How does it know where to call when exception occurs

程序在出现异常时被中断执行，异常沿着函数调用的相反方向传播直到在某个函数中异常得到了正确处理，然后程序从这里开始继续执行。这是 java, python 异常处理的一般思路。

SEH 机制和上述流程类似；和 java 以及 python 不同的是，OS 还允许使用 SEH 的程序从引起异常的指令处重新执行。整个 SEH 机制离不开一个名为 SEH 链(SEH chain)的数据结构（多数调试器，比如 ollydbg, x64dbg, 都提供查看 SEH 链的功能）。那么如何通过这个数据结构实现类似的异常传播和异常处理？

### SEH chain

SEH 链表是一个单向链接的链表。它的结点，姑且称之为 SEH 记录，其结构如下所示：

```cpp

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

// The following definition is not presented in SDK.
typedef EXCEPTION_REGISTRATION_RECORD EXCEPTION_REGISTRATION; 
```

`Next` 指向下一个结点，`Handler` 是 **异常回调函数(Exception callback function)** 的函数指针。如下图所示，SEH 链表中的所有结点在栈上在按照自底向上的顺序存储(需要注意的是，图中的`prev` 指针其实就是 `Next` 指针)。其中，第一个结点的地址由 TEB 块引用，这是因为每一个线程都需要单独的互不干涉的异常处理逻辑。

![Finding a structure to handling exception]({{ "img/win32-seh-fig04.jpg" | absolute_url }})

SEH 链表的结构随着函数调用而动态变化。当程序进入带有 `__try` 块的函数时，首先会在栈顶初始化一个 SEH 记录，使得 `Next` 指向上一个 SEH 记录，以及`Handler` 指向一个异常回调函数。由于栈同时也会生长同时为了后续可以访问 SEH 链表，程序会将 `fs:[0x0]` 的值更改为当前 SEH 记录的地址，这样 `fs:[0x0]` 指针在任何时候都能指向最靠近栈顶的 SEH 记录。

简单来说，当异常发生时，程序首先通过当前线程的 `fs:[0]` 找到第一个 SEH 结点的地址，从第一个结点开始遍历 SEH 链表直到某个结点的异常回调函数(Handler)能够正确地处理异常，最后 **程序依据这个回调函数的返回值决定控制流**。

### Exception callback

上文提到的异常回调函数的签名如下：

```cpp
int except_handler(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);
```

`EXCEPTION_RECORD` 包含了异常相关信息，其结构如下：

```cpp
typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;
```


粗略地说，正是异常回调函数对 filter 表达式求值然后决定是否调用 exception-handler 块的代码。

### The last resort exception handler

SEH 链表的最后一个结点由 OS 为所有线程在栈上生成以确保所有异常都能被处理；入口点的调用也是被`__try`/`__except` 包围。一般情况下，如果用户没有调用 `SetUnhandledExceptionFilter()` 更改函数指针，这个结点的异常处理函数会调用 `UnhandledExceptionFilter()`。在[ WER 被关闭并启用自动调试](https://docs.microsoft.com/en-us/visualstudio/debugger/debug-using-the-just-in-time-debugger?view=vs-2017#jit_errors)的情况下，这个函数的作用就是弹出一个深表歉意的对话框，然后让你选择是退出还是调试。如果你选择调试，那么实时调试器就会启动并且附加到当前进程。

顺带一提，启动调试器这个过程涉及进程间通信。这一过程通过在命令参数中传递事件的句柄来实现共享内核对象。（其实句柄只是索引而已。）

## Stack unwinding

鉴于函数之间存在嵌套调用关系，引发异常的函数和异常得到处理的函数（不是异常回调函数）可能不是同一个。这意味着控制流可能不会从引发异常的地方继续：如果控制流跳回到后面的 caller，caller 以前的函数（包括引起异常的函数）可能无法正常退出。

- caller()
    - callee()
        - exception_happen()

为了实现函数的正常退出，程序会执行一种称为 **stack unwinding**的操作，这个操作的意义在于：

- 还原异常回调函数所在的上下文。相应寄存器比如 ebp 被还原为位于这个栈帧时的值，这是因为 ebp
- 释放资源。比如 C++ 标准规定局部变量的析构函数必须被调用。如果栈帧的异常回调函数无法处理异常，析构函数将无法执行。

异常回调函数可以通过参数区分它是正在被第一次调用还是第二次调用：将 `ExceptionFlags` 的 `EH_UNWINDING` 位设置为 1 表示当前正在进行 stack unwinding 操作。那些对异常无能为力的回调函数将在这个过程中完成自己的善后工作。发生 stack unwinding 之后，在栈上所有位于 caller 之前的内容都被擦除（其实只是简单地压低栈顶而已），这当然也包括了 SEH 记录。

## A compiler's perspective

实际上 SEH 记录 `EXCEPTION_REGISTRATION` 的结构可能比单纯两个指针要复杂得多；而且 `__try`/`__except` 块和 SEH 记录并非一一对应关系。

暂且把关注焦点放到异常处理函数上。事实上多数 SEH 记录的 `Handler` 指针都指向同一个函数。在 VS2017 （默认工具集或兼容XP的工具集）编译出来的程序中，所有由用户代码 `__try`/`__except` 块生成的函数指针都指向同一个函数 `_except_handler4`；关闭 GS 选项后，这个函数指针变成了 `_except_handler3`。 尽管两个函数的实现不相同，但不管是哪一个，这两个异常回调函数都位于当前模块的 .text 段，而且异常回调函数根据 filter 表达式的值决定是否执行 exception-handler 块的代码；后者是明确写在 [MSDN](https://docs.microsoft.com/en-us/windows/desktop/debug/frame-based-exception-handling) 上的。

### Exception callback - `_except_handler3`

`_except_handler3` 对应一个更加复杂的 SEH 记录结构：

```cpp

struct scopetable_entry;

struct EXCEPTION_REGISTRATION {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
    scopetable_entry* scopetable;
    int trylevel;
    int _ebp;
};

struct scopetable_entry {
    DWORD previousTryLevel;
    PROC lpfnFilter;
    PROC lpfnHandler;
};
```

引入 scopetable 使得一个 SEH 记录能存储多个位于同一函数内的 filter 和 handler：filter 对应 `__except` 后的表达式，handler 对应 exception-handler 块的代码。`scopetable_entry` 之间靠索引 `previousTryLevel` 串成单向链表；而 `EXCEPTION_REGISTRATION::trylevel` 表示适用于当前异常处理的 `scopetable_entry` 链表的头节点。

`_except_handler3` 的[伪代码](https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/Win32SEH.chm/fig09.htm)很长。它的执行流程大体如下

1. 判断是否正在进行 unwinding 操作，若是，跳到4；否则继续。
2. 遍历 scopetable 链表，执行 filter 并根据 filter() 返回值采取不同做法：
    - `EXCEPTION_CONTINUE_SEARCH`: 继续遍历 scopetable 链表
    - `EXCEPTION_CONTINUE_EXECUTION`: 返回 `ExceptionContinueExecution`
    - `EXCEPTION_EXECUTE_HANDLER`: 
        - 调用 `__global_unwind2()`，这个函数最终会调用 `_except_handler3`；
        - 执行 `__local_unwind2()` 清理当前栈帧；
        - 执行 handler() 并不会再返回到 `_except_handler3`。
3. 如果 scopetable 链表中所有 filter 都返回 `EXCEPTION_CONTINUE_SEARCH`，这表示当前 `_except_handler3` 无法处理这个异常，返回 `DISPOSITION_CONTINUE_SEARCH`。
4. 执行 `__local_unwind2()` 清理当前栈帧。

在栈上布置 `EXCEPTION_REGISTRATION` 的代码仍然由编译器生成；然而对于 ntdll 来说，它只看得到两个指针而已。



#### Show SEH frames

下面的代码是在文章[例子](https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/Win32SEH.chm/fig10.htm)的基础上稍加修改得到的。这个例子的作用是输出 SEH 链以及 scopetable 链表信息。

原来的代码编译后不能正常运行。调试发现，异常回调函数变成了 `_except_handler4`，原本应该是 scopetable 指针的地方现在存储了一个不存在于任何一个模块的“地址”，引起内存非法访问异常(0xC0000005)。

例子经过修改加上了异常处理。

```cpp
#include <Windows.h>
#include <cstdio>

typedef EXCEPTION_REGISTRATION_RECORD EXCEPTION_REGISTRATION;

struct scopetable_entry {
    DWORD previousTryLevel;
    PROC lpfnFilter;
    PROC lpfnHandler;
};

struct VC_EXCEPTION_REGISTRATION : EXCEPTION_REGISTRATION {
    scopetable_entry* scopetable;
    int trylevel;
    int _ebp;
};

extern "C" int _except_handler3(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);
extern "C" int _except_handler4(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION*, PCONTEXT, PEXCEPTION_RECORD);

void ShowScopeTableInFrame(VC_EXCEPTION_REGISTRATION*);
void WalkSEHFrame();
void Function();

int main(int argc, char* argv[], char* envp[]) {
    // TODO main
    int i;
    _try{
        i = 0x1234;
    }_except(EXCEPTION_CONTINUE_SEARCH) {
        i = 0x4321;
    }

    __try{
        Function();
    }__except(EXCEPTION_CONTINUE_SEARCH) {
        printf("caught in %s\n", __FUNCTION__);
    }
    //_asm int 3
    return 0;
}

void ShowScopeTableInFrame(VC_EXCEPTION_REGISTRATION * pVCExcRec) {
    printf("Frame: 0x%p Handler: 0x%p Prev: 0x%p Scopetable: 0x%p\n",
        pVCExcRec, pVCExcRec->Handler, pVCExcRec->Next, pVCExcRec->scopetable);

    __try {
        scopetable_entry* pScopeTableEntry = pVCExcRec->scopetable;
        for (int i = 0; i <= pVCExcRec->trylevel; ++i) {
            printf(" scopetable[%u] previousTryLevel: %08X filter: 0x%p __except: 0x%p\n",
                i, pScopeTableEntry->previousTryLevel, pScopeTableEntry->lpfnFilter, pScopeTableEntry->lpfnHandler);

            pScopeTableEntry++;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        printf(" Exception occurs. Code:0x%08X\n", GetExceptionCode());
    }

    printf("\n");
}

void WalkSEHFrame() {
    printf("_except_handler3 is at address: 0x%p\n", _except_handler3);
    printf("_except_handler4 is at address: 0x%p\n", _except_handler4);

    VC_EXCEPTION_REGISTRATION* pVCExcRec;
    _asm {
        mov eax, fs:[0x0]
        mov pVCExcRec, eax
    }
    printf("The top SEH node is at address: 0x%p\n\n", pVCExcRec);

    while (0xffffffff != (unsigned)pVCExcRec) {
        ShowScopeTableInFrame(pVCExcRec);
        pVCExcRec = (VC_EXCEPTION_REGISTRATION*)pVCExcRec->Next;
    }
}

void Function() {

    __try {
        __try {
            __try {
                WalkSEHFrame();
            } __except (EXCEPTION_CONTINUE_SEARCH) {

            }
        } __except (EXCEPTION_CONTINUE_SEARCH) {

        }
    } __except (EXCEPTION_CONTINUE_SEARCH) {

    }

}
```

OS|IDE|Configuration
-|-|-
Windows 10 x64|VS2017|Debug|

- 默认开启 GS

![Disabled security check]({{ "img/win32-seh-showsehframes-gs.png" | absolute_url }})

- 关闭 GS

![Disabled security check]({{ "img/win32-seh-showsehframes.png" | absolute_url }})


从上边两个图片可以看出来 VS2017 的编译器默认使用 `_except_handler4` 作为异常回调函数，而且对应的 `EXCEPTION_REGISTRATION` 不同于 `_except_handler3`。

## Conclusion


对于 ntdll 而言，ntdll 只要找到 SEH 链，调用异常回调函数然后根据其返回值决定下一步行动。然而实际上更多的工作，包括（stack unwinding, 嵌套`__try`/`__except`）靠编译器生成代码来完成。

本文只涉及了 SEH 机制的小部分内容，许多详细的细节并未提及，比如异常回调函数的调用者 ntdll 的 `KiUserExceptionDispatcher()`（这个函数负责遍历 SEH 链）和实际上完成 unwind 操作的 `RtlUnwind()`。更多的内容还要拜读 Matt Peitrek 的[原文](https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm)。

